# Scoop - Database Schema Documentation

## Table of Contents
1. [Database Overview](#database-overview)
2. [Collections Structure](#collections-structure)
3. [Data Models](#data-models)
4. [Relationships](#relationships)
5. [Indexes](#indexes)
6. [Security Rules](#security-rules)

---

## Database Overview

**Database Type**: Cloud Firestore (NoSQL Document Database)

**Why NoSQL**:
- Flexible schema allows iteration during development
- Real-time sync for instant messaging
- Automatic scaling as user base grows
- Native integration with Firebase Authentication

**Key Concepts**:
- **Collection**: Like a table in SQL (e.g., "users", "matches")
- **Document**: Like a row in SQL (e.g., one user, one match)
- **Field**: Like a column in SQL (e.g., "email", "age")
- **Subcollection**: Collection nested inside a document

---

## Collections Structure

```
firestore (root)
│
├── users/                          # User profiles and authentication data
│   ├── {userId}/                   # Document for each user
│   │   ├── swipeLogs/              # Subcollection: User's swipe history
│   │   │   └── {swipeId}/
│   │   └── blockedUsers/           # Subcollection: Users this user has blocked
│   │       └── {blockedUserId}/
│
├── matches/                        # All matches between users
│   └── {matchId}/
│       └── messages/               # Subcollection: Chat messages for this match
│           └── {messageId}/
│
├── swipeLogs/                      # Global swipe activity log (for analytics)
│   └── {swipeId}/
│
├── reports/                        # User reports for moderation
│   └── {reportId}/
│
└── analytics/                      # App usage metrics
    └── {date}/
```

---

## Data Models

### 1. Users Collection
**Path**: `/users/{userId}`

Each document represents one user's profile and account data.

```javascript
{
  // === AUTHENTICATION & IDENTITY ===
  "userId": "abc123xyz",                    // Auto-generated by Firebase Auth (unique)
  "email": "john@example.com",              // User's email (verified)
  "phoneNumber": "+1234567890",             // Optional: Phone for verification
  "authProvider": "email",                  // "email", "phone", "google", etc.
  "emailVerified": true,                    // Has user verified their email?
  "createdAt": Timestamp,                   // Account creation date

  // === PROFILE INFORMATION ===
  "displayName": "John",                    // First name only (privacy)
  "age": 28,                                // Calculated from birthdate
  "birthdate": "1997-05-15",                // Store for age verification, not displayed
  "gender": "male",                         // "male", "female", "non-binary", "other"
  "bio": "Software engineer who loves hiking...",  // Max 500 characters
  "photos": [                               // Array of photo URLs
    "https://storage.googleapis.com/scoop/photos/user123/photo1.jpg",
    "https://storage.googleapis.com/scoop/photos/user123/photo2.jpg",
    "https://storage.googleapis.com/scoop/photos/user123/photo3.jpg"
  ],
  "photoCount": 3,                          // Quick reference (min 3 required)

  // === LOCATION ===
  "location": {
    "city": "San Francisco",                // City name (privacy - not exact address)
    "state": "CA",
    "country": "USA",
    "coordinates": {                        // City center coordinates (not user's exact GPS)
      "latitude": 37.7749,
      "longitude": -122.4194
    }
  },

  // === PREFERENCES ===
  "preferences": {
    "genderPreference": "female",           // Who they want to see
    "ageMin": 25,                           // Minimum age preference
    "ageMax": 35,                           // Maximum age preference
    "maxDistance": 25,                      // Maximum distance in miles
    "dealbreakers": []                      // Future: Store important filters
  },

  // === OPTIONAL PROFILE FIELDS ===
  "occupation": "Software Engineer",
  "education": "Bachelor's Degree",
  "height": 72,                             // Height in inches (5'10" = 70)
  "interests": ["hiking", "cooking", "travel", "photography"],

  // === ACCOUNT STATUS ===
  "accountStatus": "active",                // "active", "paused", "banned", "deleted"
  "pausedAt": Timestamp | null,             // When account was paused
  "pauseReason": "inactivity",              // Why paused: "inactivity", "user_request"
  "lastActiveDate": Timestamp,              // Last time user opened app or sent message
  "profileCompleteness": 85,                // Percentage (min 80% to start swiping)

  // === CONSTRAINT TRACKING ===
  "swipesRemaining": 7,                     // How many swipes left today (max 10)
  "lastSwipeReset": Timestamp,              // When swipes were last reset to 10
  "activeMatchCount": 3,                    // Current number of active matches (max 5)
  "pendingMatchCount": 1,                   // Matches waiting for slot to open

  // === NOTIFICATIONS ===
  "pushToken": "fcm-token-xyz",             // Firebase Cloud Messaging token
  "notificationSettings": {
    "newMatches": true,                     // Notify on new matches
    "messages": true,                       // Notify on new messages
    "dailyReminder": true,                  // Remind to use daily swipes
    "marketingEmails": false                // Promotional content
  },

  // === MODERATION ===
  "warningCount": 0,                        // Number of warnings received
  "isBanned": false,
  "banReason": null,

  // === METADATA ===
  "updatedAt": Timestamp,                   // Last profile update
  "version": 1                              // Schema version (for future migrations)
}
```

**Field Explanations**:

| Field | Type | Required | Purpose | Validation |
|-------|------|----------|---------|------------|
| `userId` | String | Yes | Unique identifier | Auto-generated by Firebase |
| `email` | String | Yes | User's email address | Valid email format |
| `age` | Number | Yes | User's age | 18-99 |
| `photos` | Array | Yes | Profile photos | Min 3, max 6 photos |
| `bio` | String | Yes | User's bio | Min 50, max 500 chars |
| `swipesRemaining` | Number | Yes | Daily swipe tracker | 0-10 |
| `activeMatchCount` | Number | Yes | Current matches | 0-5 |
| `accountStatus` | String | Yes | Account state | "active", "paused", "banned" |
| `lastActiveDate` | Timestamp | Yes | Inactivity tracking | Updated on any app action |

---

### 2. SwipeLogs Subcollection
**Path**: `/users/{userId}/swipeLogs/{swipeId}`

Tracks every swipe a user makes (used for analytics and preventing re-showing profiles).

```javascript
{
  "swipeId": "swipe_abc123",                // Auto-generated unique ID
  "userId": "abc123xyz",                    // Who swiped (redundant but useful)
  "targetUserId": "def456uvw",              // Who was swiped on
  "direction": "right",                     // "left" (no) or "right" (yes)
  "timestamp": Timestamp,                   // When the swipe happened
  "mutualMatch": true,                      // Was this a mutual match?
  "matchId": "match_xyz789"                 // If match created, reference it
}
```

**Why This Exists**:
- Ensures users never see the same profile twice
- Analytics: What types of profiles get swiped right?
- Debugging: Track user behavior patterns
- Prevent user from swiping on someone they already swiped on

---

### 3. Matches Collection
**Path**: `/matches/{matchId}`

Each document represents a match between two users.

```javascript
{
  "matchId": "match_abc123",                // Auto-generated unique ID
  "participants": [                         // Array of two user IDs
    "abc123xyz",
    "def456uvw"
  ],

  // === MATCH STATUS ===
  "status": "active",                       // "active", "pending_for_user1", "pending_for_user2", "pending_for_both", "unmatched"
  "createdAt": Timestamp,                   // When mutual swipe happened

  // === CHAT METADATA ===
  "lastMessage": {
    "text": "Hey! How's your weekend?",     // Preview of last message
    "senderId": "abc123xyz",                // Who sent it
    "timestamp": Timestamp,                 // When it was sent
    "isRead": false                         // Has recipient read it?
  },
  "messageCount": 15,                       // Total messages exchanged
  "lastMessageAt": Timestamp,               // When last message was sent (for sorting)

  // === UNMATCH TRACKING ===
  "unmatchedAt": null,                      // When match was ended (if applicable)
  "unmatchedBy": null,                      // Who initiated unmatch
  "unmatchReason": null,                    // Optional: Why unmatch ("not_interested", "offensive", etc.)

  // === METADATA ===
  "updatedAt": Timestamp                    // Last update to match
}
```

**Status Explanation**:
- `active`: Both users have available match slots, chat is unlocked
- `pending_for_user1`: User 1 has 5 matches, waiting for them to unmatch someone
- `pending_for_user2`: User 2 has 5 matches, waiting for them to unmatch someone
- `pending_for_both`: Both users at capacity, waiting for either to free a slot
- `unmatched`: Match was ended by one user

---

### 4. Messages Subcollection
**Path**: `/matches/{matchId}/messages/{messageId}`

All chat messages for a specific match.

```javascript
{
  "messageId": "msg_abc123",                // Auto-generated unique ID
  "matchId": "match_xyz789",                // Parent match reference
  "senderId": "abc123xyz",                  // Who sent the message
  "text": "Hey! How's it going?",           // Message content
  "timestamp": Timestamp,                   // When message was sent

  // === READ RECEIPTS ===
  "isRead": false,                          // Has recipient seen it?
  "readAt": null,                           // When it was read

  // === MODERATION ===
  "isFlagged": false,                       // Reported as inappropriate
  "flagReason": null,                       // If flagged, why?

  // === FUTURE FEATURES ===
  "attachments": [],                        // Photos, GIFs (future)
  "reactions": {}                           // Emoji reactions (future)
}
```

**Why Subcollection**:
- Each match can have thousands of messages
- Keeps match document lightweight
- Efficient querying (only load recent messages)

---

### 5. Global SwipeLogs Collection
**Path**: `/swipeLogs/{swipeId}`

Duplicate of user swipe logs but stored globally for analytics.

```javascript
{
  "swipeId": "swipe_abc123",
  "userId": "abc123xyz",
  "targetUserId": "def456uvw",
  "direction": "right",
  "timestamp": Timestamp,
  "mutualMatch": true,
  "matchId": "match_xyz789",

  // === ANALYTICS FIELDS ===
  "userAge": 28,                            // For demographic analysis
  "targetAge": 26,
  "distanceBetween": 12                     // Miles between users
}
```

**Purpose**: Analytics dashboard, A/B testing, understanding user behavior

---

### 6. Reports Collection
**Path**: `/reports/{reportId}`

User-submitted reports for inappropriate behavior.

```javascript
{
  "reportId": "report_abc123",
  "reporterId": "abc123xyz",                // Who submitted the report
  "reportedUserId": "def456uvw",            // Who is being reported
  "reason": "inappropriate_messages",       // "fake_profile", "harassment", "inappropriate_messages", "other"
  "description": "This user sent offensive messages...",  // Optional details
  "evidence": {
    "matchId": "match_xyz789",              // If related to a match
    "messageId": "msg_abc456",              // If reporting specific message
    "screenshots": []                       // Future: Allow screenshot uploads
  },
  "status": "pending",                      // "pending", "reviewed", "action_taken", "dismissed"
  "reviewedBy": null,                       // Admin who reviewed
  "reviewedAt": null,
  "actionTaken": null,                      // "warning", "ban", "no_action"
  "createdAt": Timestamp
}
```

---

### 7. BlockedUsers Subcollection
**Path**: `/users/{userId}/blockedUsers/{blockedUserId}`

Users that this user has blocked.

```javascript
{
  "blockedUserId": "def456uvw",             // Who is blocked
  "blockedAt": Timestamp,                   // When block happened
  "reason": "not_interested"                // Optional: Why blocked
}
```

**Impact of Blocking**:
- Blocked user will never appear in swipe deck again
- Blocked user cannot see blocker's profile
- Existing match (if any) is automatically ended
- No notification sent to blocked user (privacy)

---

## Relationships

### User to Matches (Many-to-Many)
```
User A ←→ Match 1 ←→ User B
User A ←→ Match 2 ←→ User C
User B ←→ Match 3 ←→ User D
```

**How to Query**:
- Find all matches for User A:
  ```javascript
  matches.where('participants', 'array-contains', 'userA_id')
  ```

---

### Match to Messages (One-to-Many)
```
Match 1
  ├── Message 1
  ├── Message 2
  └── Message 3
```

**How to Query**:
- Get recent messages for Match 1:
  ```javascript
  matches/{matchId}/messages
    .orderBy('timestamp', 'desc')
    .limit(20)
  ```

---

### User to SwipeLogs (One-to-Many)
```
User A
  ├── Swipe 1 (on User B)
  ├── Swipe 2 (on User C)
  └── Swipe 3 (on User D)
```

**How to Query**:
- Check if User A already swiped on User B:
  ```javascript
  users/userA/swipeLogs
    .where('targetUserId', '==', 'userB_id')
  ```

---

## Indexes

Indexes make queries fast. Firestore auto-creates some, but we need custom ones for complex queries.

### Required Composite Indexes

1. **Find Active Users Near Me (Swipe Deck Query)**
   ```javascript
   Collection: users
   Fields:
     - accountStatus (Ascending)
     - location.coordinates (Geopoint)
     - age (Ascending)
   ```

2. **Find Pending Matches for User**
   ```javascript
   Collection: matches
   Fields:
     - participants (Array-contains)
     - status (Ascending)
     - createdAt (Descending)
   ```

3. **Get Unread Messages**
   ```javascript
   Collection: messages (subcollection)
   Fields:
     - isRead (Ascending)
     - timestamp (Descending)
   ```

4. **Analytics: Daily Swipe Activity**
   ```javascript
   Collection: swipeLogs
   Fields:
     - timestamp (Descending)
     - direction (Ascending)
   ```

---

## Security Rules

Firestore Security Rules control who can read/write data.

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // === HELPER FUNCTIONS ===
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // === USERS COLLECTION ===
    match /users/{userId} {
      // Anyone authenticated can read basic profile data
      allow read: if isAuthenticated();

      // Only the user can write their own profile
      allow write: if isOwner(userId);

      // Subcollection: Swipe Logs
      match /swipeLogs/{swipeId} {
        allow read, write: if isOwner(userId);
      }

      // Subcollection: Blocked Users
      match /blockedUsers/{blockedUserId} {
        allow read, write: if isOwner(userId);
      }
    }

    // === MATCHES COLLECTION ===
    match /matches/{matchId} {
      // Only participants can read/write match data
      allow read, write: if isAuthenticated() &&
        request.auth.uid in resource.data.participants;

      // Subcollection: Messages
      match /messages/{messageId} {
        // Only match participants can read messages
        allow read: if isAuthenticated() &&
          request.auth.uid in get(/databases/$(database)/documents/matches/$(matchId)).data.participants;

        // Only match participants can send messages
        allow create: if isAuthenticated() &&
          request.auth.uid in get(/databases/$(database)/documents/matches/$(matchId)).data.participants;

        // Only sender can delete their own messages
        allow delete: if isAuthenticated() &&
          request.auth.uid == resource.data.senderId;
      }
    }

    // === REPORTS COLLECTION ===
    match /reports/{reportId} {
      // Anyone can create a report
      allow create: if isAuthenticated();

      // Only admins can read/update reports (admin check in Cloud Function)
      allow read, update: if false;  // Handled by Cloud Functions
    }

    // === GLOBAL SWIPE LOGS ===
    match /swipeLogs/{swipeId} {
      // Read-only for analytics (written by Cloud Functions)
      allow read: if isAuthenticated();
      allow write: if false;  // Only Cloud Functions can write
    }
  }
}
```

**Security Principles**:
1. **Authentication Required**: No unauthenticated access to any data
2. **Ownership**: Users can only edit their own profiles
3. **Privacy**: Can't see who swiped on you unless mutual match
4. **Match Privacy**: Only matched users can see each other's messages
5. **Moderation**: Reports handled server-side (prevent tampering)

---

## Data Size Considerations

### Storage Estimates (per user)
- **User Document**: ~5 KB
- **SwipeLogs** (10/day for 30 days): ~15 KB
- **Messages** (avg 50 messages/match): ~25 KB per match
- **Photos** (3-6 photos, ~500 KB each): ~2 MB

**1,000 users**:
- User data: 5 MB
- Swipe logs: 15 MB
- Messages (500 matches): 12.5 MB
- Photos: 2 GB
- **Total**: ~2 GB

**Firebase Free Tier**: 1 GB storage, 10 GB bandwidth
**Conclusion**: Need paid plan once you hit ~500 active users

---

## Database Migration Strategy

As app evolves, schema will change. How to handle?

### Version Field
Every document has `"version": 1`

### Migration Example
If we add a new required field `"zodiacSign"`:

```javascript
// Cloud Function runs periodically
function migrateUsers() {
  users.where('version', '<', 2).forEach(user => {
    user.zodiacSign = calculateZodiac(user.birthdate);
    user.version = 2;
    user.save();
  });
}
```

**Best Practice**: Always make new fields optional initially

---

## Summary

This database schema:
- ✅ Supports all constraint logic (swipe limits, match limits, inactivity)
- ✅ Enables real-time chat
- ✅ Scales with user growth
- ✅ Protects user privacy with security rules
- ✅ Tracks analytics for product improvement
- ✅ Handles moderation and reporting

**Next Document**: Review API_REFERENCE.md to understand how the app reads/writes this data.
